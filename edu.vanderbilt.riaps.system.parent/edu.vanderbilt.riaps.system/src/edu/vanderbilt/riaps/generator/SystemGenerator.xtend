/*
 * generated by Xtext 2.10.0
 */
package edu.vanderbilt.riaps.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.google.inject.Inject

import com.google.inject.Provider
import edu.vanderbilt.riaps.SystemStandaloneSetup
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.GeneratorContext
import org.eclipse.xtext.generator.GeneratorDelegate
import org.eclipse.xtext.util.CancelIndicator
import org.eclipse.xtext.validation.CheckMode
import org.eclipse.xtext.validation.IResourceValidator
import edu.vanderbilt.riaps.AppStandaloneSetup
import edu.vanderbilt.riaps.app.ComponentFormal;

import java.util.HashSet
import org.eclipse.xtext.generator.JavaIoFileSystemAccess
import org.eclipse.xtext.generator.OutputConfiguration
import org.eclipse.xtext.generator.IFileSystemAccess
import java.util.HashMap
import java.util.Map
import edu.vanderbilt.riaps.RiapsOutputConfigurationProvider

/**
 * Generates code from your model files on save.
 *  
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SystemGenerator extends AbstractGenerator {

	@Inject RiapsSystemGenerator g1

	// @Inject NodeCategoryGenerator g2
	// @Inject GoalDescriptionsGenerator g3
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		g1.doGenerate(resource, fsa, context);
	// g2.doGenerate(resource, fsa, context);
	// g3.doGenerate(resource, fsa, context);
	}

	def static main(String[] args) {
		if (args.empty) {
			System::err.println(
				'Aborting: no path to EMF resource provided!. Please provide all model files as command line argument')
			return
		}
		val ComponentFormal f = null;
		val cons = edu.vanderbilt.riaps.Console.getHeadlessInstance()
		// cons.log(java.util.logging.Level.INFO, "starting the interpreter")
		val injector = new SystemStandaloneSetup().createInjectorAndDoEMFRegistration
		val injectorApp = new AppStandaloneSetup().createInjectorAndDoEMFRegistration()
		val main = injector.getInstance(SystemGenerator)
		val generatorApp = injectorApp.getInstance(AppGenerator);
		main.runGenerator(args, generatorApp)

	}

	@Inject Provider<ResourceSet> resourceSetProvider
	@Inject IResourceValidator validator
	@Inject GeneratorDelegate generator
	@Inject StandAloneFileSystemAccess fileAccess

	def protected runGenerator(String [] strings, AppGenerator appgenerator) {
		// Load the resource
		val set = resourceSetProvider.get
		var rX = new HashSet<Resource>()
		for (x : strings) {
			val resource2 = set.getResource(URI.createFileURI(x), true)
			rX.add(resource2)
		}

		var noIssues = true
		// Validate the resource
		for (resource : rX) {
			val issues = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl)
			if (!issues.empty) {
				issues.forEach[System.err.println(it)]
				noIssues = false
			// return
			}
		}

		if (!noIssues) {
			return
		}

		// Configure and start the generator
		fileAccess.outputPath = '.'
		val context = new GeneratorContext => [
			cancelIndicator = CancelIndicator.NullImpl
		]
		for (resource : rX) {
			generator.generate(resource, fileAccess, context)
			appgenerator.doGenerate(resource, fileAccess, context)

		}
		System.out.println('Code generation finished.')
	}
}

class StandAloneFileSystemAccess extends JavaIoFileSystemAccess {
	override void generateFile(String fileName, String outputConfigName, CharSequence contents) {
		var OutputConfiguration outputConfig = getOutputConfig(outputConfigName);
		var file = getFile(fileName, outputConfigName);
		// if (file.exists() && outputConfig.isOverrideExistingResources()) {
		super.generateFile(fileName, outputConfigName, contents);
	// } 
	}

	override Map<String, OutputConfiguration> getOutputConfigurations() {
		var Map<String, OutputConfiguration> hash1 = new HashMap<String, OutputConfiguration>()

		var OutputConfiguration outputconfig = new OutputConfiguration(IFileSystemAccess::DEFAULT_OUTPUT)
		outputconfig.setDescription("Output Folder")
		outputconfig.setOutputDirectory("./apps")
		outputconfig.setOverrideExistingResources(true)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(true)
		outputconfig.setSetDerivedProperty(true)
		hash1.put(IFileSystemAccess::DEFAULT_OUTPUT, outputconfig)

		outputconfig = new OutputConfiguration(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_BASE_INCLUDE)
		outputconfig.setDescription("Output Folder")
		outputconfig.setOutputDirectory("./apps/include/base")
		outputconfig.setOverrideExistingResources(true)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(true)
		outputconfig.setSetDerivedProperty(true)
		hash1.put(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_BASE_INCLUDE, outputconfig)

		outputconfig = new OutputConfiguration(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_BASE_SRC)
		outputconfig.setDescription("Output Folder")
		outputconfig.setOutputDirectory("./apps/src/base")
		outputconfig.setOverrideExistingResources(true)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(true)
		outputconfig.setSetDerivedProperty(true)

		hash1.put(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_BASE_SRC, outputconfig)

		outputconfig = new OutputConfiguration(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_DEV_INCLUDE)
		outputconfig.setDescription("Output Folder")
		outputconfig.setOutputDirectory("./apps/include/dev")
		outputconfig.setOverrideExistingResources(false)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(false)
		outputconfig.setSetDerivedProperty(false)

		hash1.put(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_DEV_INCLUDE, outputconfig)

		outputconfig = new OutputConfiguration(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_DEV_SRC)
		outputconfig.setDescription("Output Folder")
		outputconfig.setOutputDirectory("./apps/src/dev")
		outputconfig.setOverrideExistingResources(false)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(false)
		outputconfig.setSetDerivedProperty(false)

		hash1.put(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_DEV_SRC, outputconfig)

		outputconfig = new OutputConfiguration(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_JSON_APP)
		outputconfig.setDescription("Output JSON")
		outputconfig.setOutputDirectory("./apps/configs/")
		outputconfig.setOverrideExistingResources(true)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(true)
		outputconfig.setSetDerivedProperty(true)

		hash1.put(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_JSON_APP, outputconfig)

		outputconfig = new OutputConfiguration(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_MESSAGE)
		outputconfig.setDescription("Output Folder")
		outputconfig.setOutputDirectory("./apps/messages/")
		outputconfig.setOverrideExistingResources(true)
		outputconfig.setCreateOutputDirectory(true)
		outputconfig.setCleanUpDerivedResources(true)
		outputconfig.setSetDerivedProperty(true)
		hash1.put(RiapsOutputConfigurationProvider.DEFAULT_OUTPUT_MESSAGE, outputconfig)
		return hash1
	}

}
