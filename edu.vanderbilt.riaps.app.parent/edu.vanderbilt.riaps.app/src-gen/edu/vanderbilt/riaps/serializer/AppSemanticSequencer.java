/*
 * generated by Xtext 2.10.0
 */
package edu.vanderbilt.riaps.serializer;

import com.google.inject.Inject;
import edu.vanderbilt.riaps.app.Actor;
import edu.vanderbilt.riaps.app.ActorFormal;
import edu.vanderbilt.riaps.app.Actual;
import edu.vanderbilt.riaps.app.ActualValue;
import edu.vanderbilt.riaps.app.AppComponent;
import edu.vanderbilt.riaps.app.AppPackage;
import edu.vanderbilt.riaps.app.Application;
import edu.vanderbilt.riaps.app.Artifact;
import edu.vanderbilt.riaps.app.BoolDefault;
import edu.vanderbilt.riaps.app.ClntPort;
import edu.vanderbilt.riaps.app.CollocateConstraint;
import edu.vanderbilt.riaps.app.ComponentCollection;
import edu.vanderbilt.riaps.app.ComponentFormal;
import edu.vanderbilt.riaps.app.Deadline;
import edu.vanderbilt.riaps.app.DeviceComponent;
import edu.vanderbilt.riaps.app.DistributeConstraint;
import edu.vanderbilt.riaps.app.Import;
import edu.vanderbilt.riaps.app.InsPort;
import edu.vanderbilt.riaps.app.Instance;
import edu.vanderbilt.riaps.app.InstanceSection;
import edu.vanderbilt.riaps.app.MemoryUnits;
import edu.vanderbilt.riaps.app.Message;
import edu.vanderbilt.riaps.app.MessageCollection;
import edu.vanderbilt.riaps.app.Model;
import edu.vanderbilt.riaps.app.NumberDefault;
import edu.vanderbilt.riaps.app.PubPort;
import edu.vanderbilt.riaps.app.RateLimit;
import edu.vanderbilt.riaps.app.ReqPort;
import edu.vanderbilt.riaps.app.Requirement;
import edu.vanderbilt.riaps.app.SrvPort;
import edu.vanderbilt.riaps.app.StringDefault;
import edu.vanderbilt.riaps.app.SubPort;
import edu.vanderbilt.riaps.app.TimPort;
import edu.vanderbilt.riaps.app.TimeUnit;
import edu.vanderbilt.riaps.app.Wire;
import edu.vanderbilt.riaps.services.AppGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AppSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AppGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AppPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AppPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case AppPackage.ACTOR_FORMAL:
				sequence_ActorFormal(context, (ActorFormal) semanticObject); 
				return; 
			case AppPackage.ACTUAL:
				sequence_Actual(context, (Actual) semanticObject); 
				return; 
			case AppPackage.ACTUAL_VALUE:
				sequence_ActualValue(context, (ActualValue) semanticObject); 
				return; 
			case AppPackage.APP_COMPONENT:
				sequence_AppComponent(context, (AppComponent) semanticObject); 
				return; 
			case AppPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case AppPackage.ARTIFACT:
				sequence_Artifact(context, (Artifact) semanticObject); 
				return; 
			case AppPackage.BOOL_DEFAULT:
				sequence_BoolDefault(context, (BoolDefault) semanticObject); 
				return; 
			case AppPackage.CLNT_PORT:
				sequence_ClntPort(context, (ClntPort) semanticObject); 
				return; 
			case AppPackage.COLLOCATE_CONSTRAINT:
				sequence_CollocateConstraint(context, (CollocateConstraint) semanticObject); 
				return; 
			case AppPackage.COMPONENT_COLLECTION:
				sequence_ComponentCollection(context, (ComponentCollection) semanticObject); 
				return; 
			case AppPackage.COMPONENT_FORMAL:
				sequence_ComponentFormal(context, (ComponentFormal) semanticObject); 
				return; 
			case AppPackage.DEADLINE:
				sequence_Deadline(context, (Deadline) semanticObject); 
				return; 
			case AppPackage.DEVICE_COMPONENT:
				sequence_DeviceComponent(context, (DeviceComponent) semanticObject); 
				return; 
			case AppPackage.DISTRIBUTE_CONSTRAINT:
				sequence_DistributeConstraint(context, (DistributeConstraint) semanticObject); 
				return; 
			case AppPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AppPackage.INS_PORT:
				sequence_InsPort(context, (InsPort) semanticObject); 
				return; 
			case AppPackage.INSTANCE:
				sequence_Instance(context, (Instance) semanticObject); 
				return; 
			case AppPackage.INSTANCE_SECTION:
				sequence_InstanceSection(context, (InstanceSection) semanticObject); 
				return; 
			case AppPackage.MEMORY_UNITS:
				sequence_MemoryUnits(context, (MemoryUnits) semanticObject); 
				return; 
			case AppPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case AppPackage.MESSAGE_COLLECTION:
				sequence_MessageCollection(context, (MessageCollection) semanticObject); 
				return; 
			case AppPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AppPackage.NUMBER_DEFAULT:
				sequence_NumberDefault(context, (NumberDefault) semanticObject); 
				return; 
			case AppPackage.PUB_PORT:
				sequence_PubPort(context, (PubPort) semanticObject); 
				return; 
			case AppPackage.RATE_LIMIT:
				sequence_RateLimit(context, (RateLimit) semanticObject); 
				return; 
			case AppPackage.REQ_PORT:
				sequence_ReqPort(context, (ReqPort) semanticObject); 
				return; 
			case AppPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case AppPackage.SRV_PORT:
				sequence_SrvPort(context, (SrvPort) semanticObject); 
				return; 
			case AppPackage.STRING_DEFAULT:
				sequence_StringDefault(context, (StringDefault) semanticObject); 
				return; 
			case AppPackage.SUB_PORT:
				sequence_SubPort(context, (SubPort) semanticObject); 
				return; 
			case AppPackage.TIM_PORT:
				sequence_TimPort(context, (TimPort) semanticObject); 
				return; 
			case AppPackage.TIME_UNIT:
				sequence_TimeUnit(context, (TimeUnit) semanticObject); 
				return; 
			case AppPackage.WIRE:
				sequence_Wire(context, (Wire) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActorFormal returns ActorFormal
	 *
	 * Constraint:
	 *     (name=ID argDefault=FormalDefault)
	 */
	protected void sequence_ActorFormal(ISerializationContext context, ActorFormal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.ACTOR_FORMAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.ACTOR_FORMAL__NAME));
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.ACTOR_FORMAL__ARG_DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.ACTOR_FORMAL__ARG_DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActorFormalAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getActorFormalAccess().getArgDefaultFormalDefaultParserRuleCall_1_1_0(), semanticObject.getArgDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (formals+=ActorFormal formals+=ActorFormal*)? 
	 *         (
	 *             (locals+=[Message|FQN] locals+=[Message|FQN]*) | 
	 *             (internals+=[Message|FQN] internals+=[Message|FQN]*) | 
	 *             (criticals+=[Message|FQN] criticals+=[Message|FQN]*)
	 *         )* 
	 *         compsection=InstanceSection 
	 *         wires+=Wire*
	 *     )
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ActualValue returns ActualValue
	 *
	 * Constraint:
	 *     (stringdefault=StringDefault | numberdefault=NumberDefault | boolDefault=BoolDefault | param=[ActorFormal|FQN])
	 */
	protected void sequence_ActualValue(ISerializationContext context, ActualValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Actual returns Actual
	 *
	 * Constraint:
	 *     (argName=[ComponentFormal|FQN] argValue=ActualValue)
	 */
	protected void sequence_Actual(ISerializationContext context, Actual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.ACTUAL__ARG_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.ACTUAL__ARG_NAME));
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.ACTUAL__ARG_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.ACTUAL__ARG_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActualAccess().getArgNameComponentFormalFQNParserRuleCall_0_0_1(), semanticObject.getArgName());
		feeder.accept(grammarAccess.getActualAccess().getArgValueActualValueParserRuleCall_2_0(), semanticObject.getArgValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns AppComponent
	 *     AppComponent returns AppComponent
	 *
	 * Constraint:
	 *     (name=ID (formals+=ComponentFormal formals+=ComponentFormal*)? (requirements+=Requirement | ports+=Port)+)
	 */
	protected void sequence_AppComponent(ISerializationContext context, AppComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Collection returns Application
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         baseapp=[Application|FQN]? 
	 *         (artifacts+=Artifact | actors+=Actor | components+=Component | messages+=Message)* 
	 *         deploymentConstraints+=DeploymentConstraint*
	 *     )
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Artifact returns Artifact
	 *
	 * Constraint:
	 *     ((jar?='jar' | sharedObject?='sharedObject' | configurationFile?='file') name=ID path=STRING)
	 */
	protected void sequence_Artifact(ISerializationContext context, Artifact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalDefault returns BoolDefault
	 *     BoolDefault returns BoolDefault
	 *
	 * Constraint:
	 *     value=BOOL
	 */
	protected void sequence_BoolDefault(ISerializationContext context, BoolDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.FORMAL_DEFAULT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.FORMAL_DEFAULT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolDefaultAccess().getValueBOOLTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Port returns ClntPort
	 *     ClntPort returns ClntPort
	 *
	 * Constraint:
	 *     (name=ID req_type=[Message|FQN] rep_type=[Message|FQN] deadline=Deadline? ratelimit=RateLimit?)
	 */
	protected void sequence_ClntPort(ISerializationContext context, ClntPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeploymentConstraint returns CollocateConstraint
	 *     CollocateConstraint returns CollocateConstraint
	 *
	 * Constraint:
	 *     (actorcollocatelist+=[Actor|FQN] actorcollocatelist+=[Actor|FQN] actorcollocatelist+=[Actor|FQN]*)
	 */
	protected void sequence_CollocateConstraint(ISerializationContext context, CollocateConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Collection returns ComponentCollection
	 *     ComponentCollection returns ComponentCollection
	 *
	 * Constraint:
	 *     (name=ID components+=Component*)
	 */
	protected void sequence_ComponentCollection(ISerializationContext context, ComponentCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentFormal returns ComponentFormal
	 *
	 * Constraint:
	 *     (name=ID argDefault=FormalDefault)
	 */
	protected void sequence_ComponentFormal(ISerializationContext context, ComponentFormal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.COMPONENT_FORMAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.COMPONENT_FORMAL__NAME));
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.COMPONENT_FORMAL__ARG_DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.COMPONENT_FORMAL__ARG_DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentFormalAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getComponentFormalAccess().getArgDefaultFormalDefaultParserRuleCall_1_1_0(), semanticObject.getArgDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Deadline returns Deadline
	 *
	 * Constraint:
	 *     (deadline=INT units=TimeUnit)
	 */
	protected void sequence_Deadline(ISerializationContext context, Deadline semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.DEADLINE__DEADLINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.DEADLINE__DEADLINE));
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.DEADLINE__UNITS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.DEADLINE__UNITS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeadlineAccess().getDeadlineINTTerminalRuleCall_1_0(), semanticObject.getDeadline());
		feeder.accept(grammarAccess.getDeadlineAccess().getUnitsTimeUnitParserRuleCall_2_0(), semanticObject.getUnits());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns DeviceComponent
	 *     DeviceComponent returns DeviceComponent
	 *
	 * Constraint:
	 *     (name=ID (formals+=ComponentFormal formals+=ComponentFormal*)? (requirements+=Requirement | ports+=Port)+)
	 */
	protected void sequence_DeviceComponent(ISerializationContext context, DeviceComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeploymentConstraint returns DistributeConstraint
	 *     DistributeConstraint returns DistributeConstraint
	 *
	 * Constraint:
	 *     (actordistributelist+=[Actor|FQN] actordistributelist+=[Actor|FQN] actordistributelist+=[Actor|FQN]*)
	 */
	protected void sequence_DistributeConstraint(ISerializationContext context, DistributeConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=ImportedFQN
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceImportedFQNParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Port returns InsPort
	 *     InsPort returns InsPort
	 *
	 * Constraint:
	 *     (name=ID spec?='default'?)
	 */
	protected void sequence_InsPort(ISerializationContext context, InsPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstanceSection returns InstanceSection
	 *
	 * Constraint:
	 *     instances+=Instance+
	 */
	protected void sequence_InstanceSection(ISerializationContext context, InstanceSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns Instance
	 *
	 * Constraint:
	 *     (name=ID type=[Component|FQN] (actuals+=Actual actuals+=Actual*)?)
	 */
	protected void sequence_Instance(ISerializationContext context, Instance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemoryUnits returns MemoryUnits
	 *
	 * Constraint:
	 *     (kb?='KB' | mb?='MB' | gb?='GB')
	 */
	protected void sequence_MemoryUnits(ISerializationContext context, MemoryUnits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Collection returns MessageCollection
	 *     MessageCollection returns MessageCollection
	 *
	 * Constraint:
	 *     (name=ID messages+=Message*)
	 */
	protected void sequence_MessageCollection(ISerializationContext context, MessageCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (name=ID type=[FStructType|FQN] key=[FField|FQN]?)
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=FQN imports+=Import* collections+=Collection*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalDefault returns NumberDefault
	 *     NumberDefault returns NumberDefault
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_NumberDefault(ISerializationContext context, NumberDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.FORMAL_DEFAULT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.FORMAL_DEFAULT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberDefaultAccess().getValueNumberParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Port returns PubPort
	 *     PubPort returns PubPort
	 *
	 * Constraint:
	 *     (name=ID type=[Message|FQN] ratelimit=RateLimit?)
	 */
	protected void sequence_PubPort(ISerializationContext context, PubPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RateLimit returns RateLimit
	 *
	 * Constraint:
	 *     ((lower=INT | nolower?='-') (upper=INT | noupper?='-'))
	 */
	protected void sequence_RateLimit(ISerializationContext context, RateLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns ReqPort
	 *     ReqPort returns ReqPort
	 *
	 * Constraint:
	 *     (name=ID req_type=[Message|FQN] rep_type=[Message|FQN] deadline=Deadline? ratelimit=RateLimit?)
	 */
	protected void sequence_ReqPort(ISerializationContext context, ReqPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     (
	 *         artifactrequirement=[Artifact|FQN] | 
	 *         (memoryRequirement=INT memoryunit=MemoryUnits) | 
	 *         (storageRequirement=INT storageunit=MemoryUnits) | 
	 *         deviceRequirement=STRING
	 *     )
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns SrvPort
	 *     SrvPort returns SrvPort
	 *
	 * Constraint:
	 *     (name=ID req_type=[Message|FQN] rep_type=[Message|FQN] ratelimit=RateLimit?)
	 */
	protected void sequence_SrvPort(ISerializationContext context, SrvPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalDefault returns StringDefault
	 *     StringDefault returns StringDefault
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringDefault(ISerializationContext context, StringDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.FORMAL_DEFAULT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.FORMAL_DEFAULT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringDefaultAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Port returns SubPort
	 *     SubPort returns SubPort
	 *
	 * Constraint:
	 *     (name=ID type=[Message|FQN] ratelimit=RateLimit?)
	 */
	protected void sequence_SubPort(ISerializationContext context, SubPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns TimPort
	 *     TimPort returns TimPort
	 *
	 * Constraint:
	 *     (name=ID spec=Number unit=TimeUnit)
	 */
	protected void sequence_TimPort(ISerializationContext context, TimPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.PORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.PORT__NAME));
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.TIM_PORT__SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.TIM_PORT__SPEC));
			if (transientValues.isValueTransient(semanticObject, AppPackage.Literals.TIM_PORT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AppPackage.Literals.TIM_PORT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimPortAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTimPortAccess().getSpecNumberParserRuleCall_2_0_0(), semanticObject.getSpec());
		feeder.accept(grammarAccess.getTimPortAccess().getUnitTimeUnitParserRuleCall_2_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeUnit returns TimeUnit
	 *
	 * Constraint:
	 *     (
	 *         months?='months' | 
	 *         days?='days' | 
	 *         seconds?='s' | 
	 *         milliseconds?='ms' | 
	 *         nanoseconds?='ns' | 
	 *         microseconds?='mus'
	 *     )
	 */
	protected void sequence_TimeUnit(ISerializationContext context, TimeUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Wire returns Wire
	 *
	 * Constraint:
	 *     ((clnt=[ClntPort|FQN] server=[SrvPort|FQN]) | (ami?='ami' req=[ReqPort|FQN] server=[SrvPort|FQN]))
	 */
	protected void sequence_Wire(ISerializationContext context, Wire semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
