package edu.vanderbilt.riaps.generator.cpp

import edu.vanderbilt.riaps.app.Component
import edu.vanderbilt.riaps.app.Port
import java.util.HashMap
import edu.vanderbilt.riaps.app.Port
import java.util.ArrayList
import java.util.HashMap
import java.util.Map
import java.util.List
import edu.vanderbilt.riaps.app.PubPort
import edu.vanderbilt.riaps.app.SubPort
import edu.vanderbilt.riaps.app.ReqPort
import edu.vanderbilt.riaps.app.TimPort
import edu.vanderbilt.riaps.app.Application
import edu.vanderbilt.riaps.app.Message
import edu.vanderbilt.riaps.app.RepPort

@SuppressWarnings("unused", "unchecked")
class CompCpp {
	protected String componentName
	protected String applicationName
	protected var ports = new ArrayList<PortCppBase>
	protected var portMsgTypeMap = new HashMap<String, String>
	
	new (Component comp, Application app) {
		componentName = comp.name
		applicationName = app.name
		
		for (Message msg: app.messages) {
			portMsgTypeMap.put(msg.name, msg.type.name)
		}
		
		createPorts(comp)		
	}
	
	def void createPorts(Component riapsComponent) {
		for(Port port : riapsComponent.getPorts()) {
			if (port instanceof PubPort) {
				ports.add(new PubPortCpp(port, riapsComponent.name, portMsgTypeMap))
			}
			else if (port instanceof SubPort) {
				ports.add(new SubPortCpp(port, riapsComponent.name, portMsgTypeMap))			
			}
			else if (port instanceof ReqPort) {
				ports.add(new ReqPortCpp(port, riapsComponent.name, portMsgTypeMap))
			}
			else if (port instanceof RepPort) {
				ports.add(new RepPortCpp(port, riapsComponent.name, portMsgTypeMap))
			}
			else if (port instanceof TimPort) {
				ports.add(new TimerPortCpp(port, riapsComponent.name))
			}
		}	
	}
	
	
	//////////////////////////////////////////////////////////////////////////////
	// Base Gen Functions
	//////////////////////////////////////////////////////////////////////////////
	def generateBaseH() 	'''
	//
	// Auto-generated by edu.vanderbilt.riaps.generator.ComponenetGenerator.xtend
	//
	
	#ifndef RIAPS_CORE_«componentName.toUpperCase»_H
	#define RIAPS_CORE_«componentName.toUpperCase»_H
	
	#include "componentmodel/r_componentbase.h"
	#include "messages/«this.applicationName.toLowerCase».capnp.h"
	
	// Name of the ports from the model file
	«FOR PortCppBase p: ports»
	#define «p.portMacroName» "«p.portName»"
	«ENDFOR»
	
	namespace «applicationName.toLowerCase» {
	    namespace components {
	    	
	    	class «componentName»Base : public riaps::ComponentBase {
	    		
	    	public:
	    		«componentName»Base(_component_conf_j &config, riaps::Actor &actor);
	    		
	    		«FOR PortCppBase p: ports»
	    			«p.generateBaseH»
	    			
	    		«ENDFOR»
	    		
	    	    virtual ~«componentName»Base();
	    	protected:
	    		virtual void DispatchMessage(capnp::FlatArrayMessageReader* capnpreader, riaps::ports::PortBase *port);
	        };
	    }
	}
	#endif //RIAPS_CORE_«componentName.toUpperCase»_H	
	'''
	
	def generateBaseCpp() '''
	//
	// Auto-generated by edu.vanderbilt.riaps.generator.ComponenetGenerator.xtend
	//
	#include <base/«componentName»Base.h>
	
	namespace «applicationName.toLowerCase» {
	    namespace components {
	    	
	    	«componentName»Base::«componentName»Base(_component_conf_j &config, riaps::Actor &actor) : ComponentBase(config, actor) {
	    	
	    	}
	    	
	    	void «componentName»Base::DispatchMessage(capnp::FlatArrayMessageReader* capnpreader, riaps::ports::PortBase *port) {
	    		auto portName = port->GetPortName();
				«FOR PortCppBase p: ports»
				«p.generateBaseDispatch()»
				
				«ENDFOR»
	    	}
	    	
	    	«FOR PortCppBase p: ports»
	    	«p.generateBaseCpp()»
	    	«ENDFOR»
	    	
	    	«componentName»Base::~«componentName»Base() {
	    	
	    	}
	    }
	}	
	'''
	
	
	//////////////////////////////////////////////////////////////////////////////
	// FW Gen Functions
	//////////////////////////////////////////////////////////////////////////////
	def generateFW_H() 	'''
		//
		// Auto-generated by edu.vanderbilt.riaps.generator.ComponenetGenerator.xtend
		//
		#ifndef RIAPS_FW_«componentName.toUpperCase»_H
		#define RIAPS_FW_«componentName.toUpperCase»_H
		
		#include "base/«componentName»Base.h"
		
		namespace «applicationName.toLowerCase» {
		    namespace components {
		
		        class «componentName» : public «componentName»Base {
		
		        public:
		
		            «componentName»(_component_conf_j &config, riaps::Actor &actor);
		
		
		            «FOR p: ports»
		            «p.generateFW_H()»
		            
					«ENDFOR»
		
					virtual void OnOneShotTimer(const std::string& timerid);
					
		            virtual ~«componentName»();
		
		
		        private:
		            std::unique_ptr<std::uniform_real_distribution<double>> unif;
		            std::default_random_engine re;
		        };
		    }
		}
		
		extern "C" riaps::ComponentBase* create_component(_component_conf_j&, riaps::Actor& actor);
		extern "C" void destroy_component(riaps::ComponentBase*);
		
		
		#endif //RIAPS_FW_«componentName.toUpperCase»_H		
	'''
	
	def generateFW_Cpp() '''
		#include <«componentName».h>
		
		namespace «applicationName.toLowerCase» {
		    namespace components {		
		
		        «componentName»::«componentName»(_component_conf_j &config, riaps::Actor &actor) :
		                «componentName»Base(config, actor) {
		        }
		
				«FOR p: ports»
				«p.generateFW_Cpp()»
				
				«ENDFOR»

				void «componentName»::OnOneShotTimer(const std::string& timerid){
				
				}

		        «componentName»::~«componentName»() {
		
		        }
		    }
		}
		
		riaps::ComponentBase *create_component(_component_conf_j &config, riaps::Actor &actor) {
		    auto result = new «applicationName.toLowerCase»::components::«componentName»(config, actor);
		    return result;
		}
		
		void destroy_component(riaps::ComponentBase *comp) {
		    delete comp;
		}
	'''
	
	
}