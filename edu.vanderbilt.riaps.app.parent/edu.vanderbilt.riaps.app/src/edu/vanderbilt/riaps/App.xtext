grammar edu.vanderbilt.riaps.App with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//The compaonents and application definition use Messages from Datatypes
import "http://www.vanderbilt.edu/riaps/Datatypes" as DataTypes
generate app "http://www.vanderbilt.edu/riaps/App"
//This is the main model rule
Model returns Mdodel:
	{Model}
	'package' name=FQN
	(imports+=Import)*
	//Main riaps file entries.
	(collections+=Collection)*;

Import:
	'import' (importedNamespace=ImportedFQN);

ImportedFQN:
	FQN ('.' '*')?;

FQN:
	ID ('.' ID)*;

	/////////////////////////////////////////////////////////////////	
//These are the terminal Rules	
@ Override terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9' | '_')*;
terminal DECIMAL:
	INT
	(('e' | 'E') ('+' | '-')? INT)?
	(('b' | 'B') ('i' | 'I' | 'd' | 'D') | ('l' | 'L' | 'd' | 'D' | 'f' | 'F'))?; FormalDefault:
	StringDefault
	| NumberDefault
	| BoolDefault;

StringDefault:
	value=STRING;

NumberDefault:
	value=Number;

BoolDefault:
	value=BOOL;

Number hidden():
	(INT | DECIMAL) ('.' (INT | DECIMAL))?;

terminal BOOL:
	'true' | 'false';

	//We need to define terminals so that we can use them in formal parameter definitions.

//A collection defines the top level entries in the riaps file.
// These can just be component definitions or application definitions.

// These are the real FCO
Collection:
	Component
	| Application;

	// A component can be an application component or a device component.
Component:
	AppComponent | DeviceComponent;

	// This is an application component
// we capture its ports and its requirements.
// Component types used in the application
AppComponent:
	'component' name=ID
	('()' | ('(' formals+=ComponentFormal (',' formals+=ComponentFormal)* ')')?)
	'{'
	// A component can first declarate several requirements. It then declares the ports that it provides.
	(requirements+=Requirement)*
	// A component must have atleast one port 
	(ports+=Port)+
	'}';

	// A device component is similar to an application component	
DeviceComponent:
	'device' name=ID
	('()' | ('(' formals+=ComponentFormal (',' formals+=ComponentFormal)* ')')?)
	'{'
	(requirements+=Requirement)*
	// A component must have atleast one port 
	(ports+=Port)+
	'}';

/* Here we capture the resource requirements of components.  */

/*
 * Rule that defines different supported memory units. 
 */
MemoryUnits:
	kb?='KB'
	| mb?='MB'
	| gb?="GB";

	//An application component can request a specific device. But It will need to talk via a device component running on the same 
// node that also requires the same device. Here the requirement captures a device identifier that can be specialized to 
// identify a subtag for a device for example PMU.north. In this case the device type is PMU. The north is a tag that can be hierarchically matched
// against the computation node that supports that device.
// TODO DeviceTypes might have to be defined in datatypes

//TODO handle network requirements
//TODO write validation rules
Requirement:
	'requires'
	(('artifact' artifactrequirement=[Artifact|FQN])
	| ('memory' memoryRequirement=INT memoryunit=MemoryUnits)
	| ('realtimecpu') 'priority' priority=INT 'class' (fifo?='FIFO' | rr?='RR')
	//This is the CFS parameter
	| ('cpu') 'period' priority=INT 'us' 'quota' quota=INT 'us'
	| ('storage' storageRequirement=INT storageunit=MemoryUnits)
	//we refer to device types specified in the datatypes.
	| ('device' deviceRequirement=[DataTypes::DeviceType]) ('tag' tag=DeviceTagSequence)?  ('using' devicecomponent=[DeviceComponent])?) (';')?;
	

DeviceTagSequence:
	tag+=DeviceTag ('.' tag+=DeviceTag)*
;	

DeviceTag:
	name=ID
;

MessageRef:
	'message' type=[DataTypes::Message|FQN] (';')?;

Application returns Application:
	{Application}
	'app' (name=ID)
	'{'
	//declare the libraries, actors, components (app-specific components - an app's actor can use components described in a non-app namespace)
	((artifacts+=Artifact) | (actors+=Actor) | (components+=Component) | (messages+=MessageRef))*

	//Optionally deployment constraints can be specified to control how an app is deployed.
	// the constraints are specified by the app developer
	(deploymentConstraints+=DeploymentConstraint)*
	'}';

DeploymentConstraint:
	CollocateConstraint | DistributeConstraint;

CollocateConstraint:
	'collocate' actorcollocatelist+=[Actor|FQN] ',' actorcollocatelist+=[Actor|FQN] (',' actorcollocatelist+=[Actor|FQN])*
	(';'?);

DistributeConstraint:
	'distribute' actordistributelist+=[Actor|FQN] ',' actordistributelist+=[Actor|FQN] (','
	actordistributelist+=[Actor|FQN])* (';'?);

	/*
 * Rule to create (software) artifact. Artifacts can have dependencies. 
 * All artifacts are always found in RIAPSAPPS/artifacts folder
 * 
 */
Artifact:
	(jar?='jar' | sharedObject?='library' | configurationFile?='file') name=ID ('path' (path=STRING)
	/* optionally path can be pre-specified */)? (';')?;

	// Rate limits can be specified on ports.
Port:
	PubPort
	| SubPort
	| ClntPort
	| SrvPort
	| ReqPort
	| RepPort
	| TimPort
	| InsPort;

RateLimit:
	'Hz' '[' (lower=INT | nolower?='-') ',' (upper=INT | noupper?='-') ']';

	//Rate limits are optional
PubPort:
	'pub' name=ID ':' type=[DataTypes::Message|FQN] (ratelimit=RateLimit)? (';')?;

SubPort:
	'sub' name=ID ':' type=[DataTypes::Message|FQN] (ratelimit=RateLimit)? (';')?;

	//deadlines can be specified for client server ports.
Deadline:
	'within' deadline=INT units=TimeUnit;

	// Client port (request and reply message types) - Owned by an SMI client
// Client operation is expected to send on the port and then receive on the same port
ClntPort:
	'clt' name=ID ':' '(' req_type=[DataTypes::Message|FQN] ',' rep_type=[DataTypes::Message|FQN] (deadline=Deadline)? ')'
	(ratelimit=RateLimit)? (';')?;

SrvPort:
	'srv' name=ID ':' '(' req_type=[DataTypes::Message|FQN] ',' rep_type=[DataTypes::Message|FQN] ')'
	(ratelimit=RateLimit)? (';')?;

ReqPort:
	'req' name=ID ':' '(' req_type=[DataTypes::Message|FQN] ',' rep_type=[DataTypes::Message|FQN] (deadline=Deadline)? ')'
	(ratelimit=RateLimit)? (';')?;

RepPort:
	'rep' name=ID ':' '(' req_type=[DataTypes::Message|FQN] ',' rep_type=[DataTypes::Message|FQN] (deadline=Deadline)? ')'
	(ratelimit=RateLimit)? (';')?;

	/*
 * Rule that defines different supported time units.
 */
TimeUnit:
	seconds?='s'
	| milliseconds?='ms'
	| nanoseconds?='ns'
	| microseconds?='mus';

TimPort:
	'timer' name=ID (spec=Number (unit=TimeUnit)?) (';')?;

	//Inside port
InsPort:
	'inside' name=ID (spec?='default')? (';')?;

ComponentFormal:
	name=ID ('=' argDefault=FormalDefault);

ActorFormal:
	name=ID ('=' argDefault=FormalDefault);

Actor:
	'actor' name=ID ('()' | ('(' formals+=ActorFormal (',' formals+=ActorFormal)* ')')?)
	'{'
	(('local' locals+=[DataTypes::Message|FQN] (',' locals+=[DataTypes::Message|FQN])* (';')?) | ('internal'
	internals+=[DataTypes::Message|FQN] (',' internals+=[DataTypes::Message|FQN])* (';')?) | ('critical'
	criticals+=[DataTypes::Message|FQN] (',' criticals+=[DataTypes::Message|FQN])* (';')?))*
	compsection=InstanceSection
	wires+=Wire*
	'}';

	// Wiring of clients to servers (both SMI and AMI)
InstanceSection returns InstanceSection:
	{InstanceSection}
	'{'
	(instances+=Instance)+
	'}';

Wire returns Wire:
	{Wire}
	((clnt=[ClntPort|FQN] '=' server=[SrvPort|FQN]) | (ami?='ami' req=[ReqPort|FQN] '=' server=[SrvPort|FQN])) (';')?;

Actual returns Actual:
	{Actual} argName=[ComponentFormal|FQN] '=' (tringdefault=StringDefault | numberdefault=NumberDefault |
	boolDefault=BoolDefault | argValue=[ActorFormal|FQN]);

	//ActualValue:
//	(stringdefault=StringDefault | numberdefault=NumberDefault | boolDefault=BoolDefault | param=[ActorFormal|FQN]);
Instance:
	name=ID ':' type=[Component|FQN] ('(' actuals+=Actual (',' (actuals+=Actual))* ')')? (';')?;


	
