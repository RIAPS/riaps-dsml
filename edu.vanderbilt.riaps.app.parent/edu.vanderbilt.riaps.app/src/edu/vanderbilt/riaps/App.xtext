grammar edu.vanderbilt.riaps.App with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate app "http://www.vanderbilt.edu/riaps/App"
//This is the main model rule
Model returns Mdodel:
	{Model}
	//'package' name=FQN (';')?
	(imports+=Import)*
	(collections+=Collection)*;

Import:
	'import' (importedNamespace=ImportedFQN) (';')?;

ImportedFQN:
	FQN ('.' '*')?;

FQN:
	ID ('.' ID)*;
	////////////////////////////////////////////////////////////////	
//These are the terminal Rules	
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9' | '_')*;

terminal DECIMAL:
	INT
	(('e' | 'E') ('+' | '-')? INT)?
	(('b' | 'B') ('i' | 'I' | 'd' | 'D') | ('l' | 'L' | 'd' | 'D' | 'f' | 'F'))?;

FormalDefault:
	StringDefault
	| NumberDefault
	| BoolDefault;

StringDefault:
	value=STRING;

NumberDefault:
	value=Number;

BoolDefault:
	value=BOOL;

Number hidden():
	(INT | DECIMAL) ('.' (INT | DECIMAL))?;

terminal BOOL:
	'true' | 'false';

//A collection defines the top level entries in the riaps file.
// These can just be component definitions or application definitions.


Collection:
	Application
	| Component
	| DeviceType
	| FType
	| Message;

FType returns FType:
	FEnumerationType |
	FStructType;

FStructType returns FStructType:
//A message can only refer to a structure.	
	{FStructType} 'struct' name=ID '{' (elements+=FField)* '}';

FField:
//the [] declares a filed to be an array
	name=ID ':' type=FTypeRef (list?='[' ']')? (';')?;

FTypeRef returns FTypeRef:
//These are references to types.
	predefined=FBasicTypeId | derived=[FType|FQN];

enum FBasicTypeId returns FBasicTypeId:
//These are the basic types that are supported by the datatypes language
	Int8='Int8' |
	UInt8='UInt8' |
	Int16='Int16' |
	UInt16='UInt16' |
	Int32='Int32' |
	UInt32='UInt32' |
	Int64='Int64' |
	UInt64='UInt64' |
	Boolean='Boolean' |
	String='String' |
	Float='Float' |
	Double='Double' |
	Char='Char' |
	ByteBuffer='ByteBuffer';

	//We support enumerations as well. A structure can have a field that is an enumeration.	
FEnumerationType returns FEnumerationType:
	{FEnumerationType}
	'enumeration' name=ID
	'{'
	(enumerators+=FEnumerator (','? enumerators+=FEnumerator)*) (';')?
	'}';

FEnumerator returns FEnumerator:
	{FEnumerator}
	name=ID ('=' value=STRING)?;

Message:
	'message' name=ID (':' type=[FStructType|FQN])? (';')?;
	//The device types and their tags will be captured in datatypes. A different place for them can be found later.
//for crossreference 

enum SupportLanguages returns SupportLanguages:
	python ='python'|
	py='py'|
	cpp='cpp'
;
DeviceType:
	('@' 'lang'  language=SupportLanguages)?
	'device' name=ID
	('()' | ('(' formals+=ComponentFormal (',' formals+=ComponentFormal)* ')')?)
	//('from' reuselib=Library)?
	'{'
	((constraint+=DeviceUses) | (ports+=Port))+
	'}';

DeviceUses:
	{DeviceUses}
	'uses'
	'{'
	(requirements+=DeviceRequirement (';')?)*
	'}';

DeviceRequirement:
	Library | Configuration | CPURequirement | IORequirement;

IORequirement:
	'io' name=STRING;
	// A component can be an application component or a device component.

// This is an application component
// we capture its ports and its requirements.
// Component types used in the application
Component:
	('@' 'lang'  language=SupportLanguages)?
	(realtime?='rt')? 'component' name=ID
	('()' | ('(' formals+=ComponentFormal (',' formals+=ComponentFormal)* ')')?)
	//('from' reuselib=Library)? 
	'{'
	// A component can first declare several requirements. It then declares the ports that it provides.
	((constraint+=ComponentUses) | (ports+=Port) | (handler+=exceptionHandler))+
	// A component must have atleast one port 
	'}';

exceptionHandler:
	IGNORE | EXIT | NAMEDHANDLER;

NAMEDHANDLER:
	{NAMEDHANDLER}
	'except' name=ID (';')?;

IGNORE:
	{IGNORE}
	'ignore' (';')?;

EXIT:
	{EXIT}
	'exit' (';')?;

	//declare in us
CPURequirement:
	'cpu' percentage=INT '%' ('over' TimeInterval_Number=INT 'us')?;

	/*
 * Rule that defines different supported time units.
 */
TimeUnit:
	seconds?='s'
	| milliseconds?='ms'
	| microseconds?='us';

terminal libraryName:
	'lib' ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')* ('.so');
	//terminal fileName  		: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*(('.')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*);
Library:
	('library'|'lib')? (name=libraryName);

Configuration:
	'file' (name=STRING);

	// Rate limits can be specified on ports.
Port:
	PubPort
	| SubPort
	| ClntPort
	| SrvPort
	| ReqPort
	| RepPort
	| TimPort
	| QueryPort
	| AnswerPort
	| InsPort;

QueryPort:
	'qry' name=ID ':' '(' req_type=[Message|FQN] ',' rep_type=[Message|FQN] ')' (deadlinelimit=DeadlineLimit)?
	(ratelimit=RateLimit)? (';')?;

AnswerPort:
	'ans' name=ID ':' '(' req_type=[Message|FQN] ',' rep_type=[Message|FQN] ')'
	(ratelimit=RateLimit)? (';')?;

RateLimit:
	'[' (lower=INT | nolower?='-') ',' (upper=INT | noupper?='-') ']';

	//Rate limits are optional
PubPort:
	'pub' name=ID ':' type=[Message|FQN] (ratelimit=RateLimit)? (';')?;

SubPort:
	'sub' name=ID ':' type=[Message|FQN] (ratelimit=RateLimit)? (';')?;

	//deadlines can be specified for client server ports.
DeadlineLimit:
	'within' deadline=INT units=TimeUnit;

	// Client port (request and reply message types) - Owned by an SMI client
// Client operation is expected to send on the port and then receive on the same port
ClntPort:
	'clt' name=ID ':' '(' req_type=[Message|FQN] ',' rep_type=[Message|FQN] ')' (deadlinelimit=DeadlineLimit)?
	(ratelimit=RateLimit)? (';')?;

SrvPort:
	'srv' name=ID ':' '(' req_type=[Message|FQN] ',' rep_type=[Message|FQN] ')'
	(ratelimit=RateLimit)? (';')?;

ReqPort:
	'req' name=ID ':' '(' req_type=[Message|FQN] ',' rep_type=[Message|FQN] ')' (deadlinelimit=DeadlineLimit)?
	(ratelimit=RateLimit)? (';')?;

RepPort:
	'rep' name=ID ':' '(' req_type=[Message|FQN] ',' rep_type=[Message|FQN] ')'
	(ratelimit=RateLimit)? (';')?;

TimPort:
	'timer' name=ID (spec=INT (unit=TimeUnit)?) (';')?;

	//Inside port
InsPort:
	'inside' name=ID (spec?='default')? (';')?;

ComponentUses:
	{ComponentUses}
	'uses'
	'{'
	(requirements+=ComponentRequirement (';')?)+
	'}';

	/*
 * Rule that defines different supported memory units. 
 */
MemoryUnits:
	kb?='KB'
	| mb?='MB'
	| gb?="GB";

	//An application component can request a specific device. But It will need to talk via a device component running on the same 
// node that also requires the same device. Here the requirement captures a device identifier that can be specialized to 
// identify a subtag for a device for example PMU.north. In this case the device type is PMU. The north is a tag that can be hierarchically matched
// against the computation node that supports that device.
// TODO DeviceTypes might have to be defined in datatypes
ComponentRequirement:
	Library | Configuration | CPURequirement | CompDeviceRequirement | NetworkRequirement;

NetworkRequirement:
	'net' Number=INT 'MB' ('over' TimeInterval_Number=INT 'us')?;

CompDeviceRequirement:
	('device' deviceRequirement=[DeviceType] ('(' actuals+=Actual (',' (actuals+=Actual))* ')')?);
	//('tag' tag=DeviceTagSequence)?
DeviceTagSequence:
	tag+=DeviceTag ('.' tag+=DeviceTag)*;

DeviceTag:
	name=ID;

Application returns Application:
	{Application}
	'app' (name=ID)
	'{'
	//declare the libraries, actors, components (app-specific components - an app's actor can use components described in a non-app namespace)
	((actors+=Actor) | (components+=Component) | (devices+=DeviceType) | (groups+=Group) | messages+=Message)+

	//Optionally deployment constraints can be specified to control how an app is deployed.
	// the constraints are specified by the app developer
	(deploymentConstraints+=DeploymentConstraint)*
	'}';

Group:
	{Group}
	'group' name=ID '{'
	((useclauses+=UsesBlock)
	|
	(gmessageblock+=GMessageBlock))+
	'}';

UsesBlock:
	'uses' property+=GroupProperty (',' property+=GroupProperty)* (';')?;

GMessageBlock:
	'messages' '{'
	(('group' ':' groupMessages+=[Message|FQN] (',' groupMessages+=[Message|FQN])* (';')?)
	|
	('consensus' ':' consensusMessages+=[Message|FQN] (',' consensusMessages+=[Message|FQN])* (';')?))+
	'}';

GroupProperty:
	Leader
	| Consensus;

Leader:
	{Leader}
	hasLeader?=('leader');

Consensus:
	{Consensus}
	hasConsensus?=('consensus');

DeploymentConstraint:
	CollocateConstraint | DistributeConstraint;

CollocateConstraint:
	'collocate' actorcollocatelist+=[Actor|FQN] ',' actorcollocatelist+=[Actor|FQN] (',' actorcollocatelist+=[Actor|FQN])*
	(';'?);

DistributeConstraint:
	'distribute' actordistributelist+=[Actor|FQN] ',' actordistributelist+=[Actor|FQN] (','
	actordistributelist+=[Actor|FQN])* (';'?);

ComponentFormal:
	name=ID (('=' argDefault=FormalDefault)?);

ActorFormal:
	name=ID ('=' argDefault=FormalDefault);

Actor:
	'actor' name=ID ('()' | ('(' formals+=ActorFormal (',' formals+=ActorFormal)* ')')?)
	'{'
	(('local' locals+=[Message|FQN] (',' locals+=[Message|FQN])* (';')?) | ('internal'
	internals+=[Message|FQN] (',' internals+=[Message|FQN])* (';')?) | ('critical'
	criticals+=[Message|FQN] (',' criticals+=[Message|FQN])* (';')?))*
	compsection=InstanceSection
	wires+=Wire*
	((constraint=ActorUses)?)
	(handler=exceptionHandler)?
	(restartspec=RestartSpec)?
	'}';

ActorUses:
	{ActorUses}
	'uses'
	'{'
	(requirements+=ActorRequirement (';')?)*
	'}';

RestartSpec:
	{RestartSpec}
	'restart' (maxtries=INT)? ('delay' delay=INT unit=TimeUnit)? (';')?;

ActorRequirement:
	MemoryRequirement | StorageRequirement;

MemoryRequirement:
	'mem' Number=INT 'MB'?;

StorageRequirement:
	'space' Number=INT 'MB'?;
	// Wiring of clients to servers (both SMI and AMI)
InstanceSection returns InstanceSection:
	{InstanceSection}
	'{'
	(compInstances+=Instance | devInstances+=DeviceInstance)+
	'}';

Wire returns Wire:
	{Wire}
	((clnt=[ClntPort|FQN] '=' server=[SrvPort|FQN]) | (ami?='ami' req=[ReqPort|FQN] '=' server=[SrvPort|FQN])) (';')?;

Actual returns Actual:
	{Actual} argName=[ComponentFormal|FQN] '=' (tringdefault=StringDefault | numberdefault=NumberDefault |
	boolDefault=BoolDefault | argValue=[ActorFormal|FQN]);

	//ActualValue:
//	(stringdefault=StringDefault | numberdefault=NumberDefault | boolDefault=BoolDefault | param=[ActorFormal|FQN]);
Instance:
	name=ID ':' type=[Component|FQN] ('()' | ('(' actuals+=Actual (',' (actuals+=Actual))* ')'))? (';')?;

DeviceInstance:
'device' name=ID ':' deviceRequirement=[DeviceType] ('(' actuals+=Actual (',' (actuals+=Actual))* ')')? ('tag' tagsequence=DeviceTagSequence)?;


	
