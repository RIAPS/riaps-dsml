/*
 * generated by Xtext 2.10.0
 */
package edu.vanderbilt.riaps.formatting2

import com.google.inject.Inject

import edu.vanderbilt.riaps.datatypes.Import
import edu.vanderbilt.riaps.datatypes.Model
import edu.vanderbilt.riaps.services.DatatypesGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import edu.vanderbilt.riaps.datatypes.FType
//import edu.vanderbilt.riaps.datatypes.FMessage
import edu.vanderbilt.riaps.datatypes.FStructType
import edu.vanderbilt.riaps.datatypes.FField
import edu.vanderbilt.riaps.datatypes.ModelCollection
import edu.vanderbilt.riaps.datatypes.DeviceType
import edu.vanderbilt.riaps.datatypes.DeviceUses
import org.eclipse.xtext.formatting2.regionaccess.IComment
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.AbstractRule
import org.eclipse.xtext.formatting2.internal.SinglelineDocCommentReplacer
import org.eclipse.xtext.formatting2.internal.WhitespaceReplacer
import org.eclipse.xtext.formatting2.internal.SinglelineCodeCommentReplacer

class DatatypesFormatter extends AbstractFormatter2 {

	@Inject extension DatatypesGrammarAccess

	def dispatch void format(Model model, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Import imports : model.getImports()) {
			imports.format;
			imports.prepend[noSpace; newLine].append[noSpace; newLine]
		}
		model.prepend[noSpace].append[noSpace; newLine]

		for (ModelCollection Type : model.collection) {
			Type.format;
		}
//		for (FMessageCollection messageCollections : model.getMessageCollections()) {
//			messageCollections.format;
//		}
	}

	def dispatch void format(ModelCollection collection, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		val open = collection.regionFor.keyword("{").prepend[noSpace; newLine].append[noSpace; newLine]
		val close = collection.regionFor.keyword("}").prepend[noSpace; newLine].append[noSpace; newLine]
		interior(open, close)[indent]
		collection.prepend[noSpace; newLine].append[noSpace; newLine]

		if (collection instanceof FStructType) {
			for (FField e : collection.elements) {
				e.prepend[noSpace; newLine].append[noSpace; newLine]
			}
		}

		if (collection instanceof DeviceType) {
			collection.constraint.format
		}

	}

	override createCommentReplacer(IComment comment) {
		val EObject grammarElement = comment.getGrammarElement();
		if (grammarElement instanceof AbstractRule) {
			val String ruleName = grammarElement.getName();
			if (ruleName.startsWith("SL")) {
				if (comment.getLineRegions().get(0).getIndentation().getLength() > 0) {
					return new SinglelineDocCommentReplacer(comment, "//") {
						def defigureWhitespace(WhitespaceReplacer leading, WhitespaceReplacer trailing) {
							leading.getFormatting().space = "            ";
						}
					};

				} else {
					return new SinglelineCodeCommentReplacer(comment, "//") {
						def defeWhitespace(WhitespaceReplacer leading, WhitespaceReplacer trailing) {
							leading.getFormatting().space = "            ";
						}
					}
				}
			}
		}
		super.createCommentReplacer(comment)
	}

	def dispatch void format(DeviceUses collection, extension IFormattableDocument document) {
		val open = collection.regionFor.keyword("{").prepend[noSpace; newLine].append[noSpace; newLine]
		val close = collection.regionFor.keyword("}").prepend[noSpace; newLine].append[noSpace; newLine]
		interior(open, close)[indent]
		collection.prepend[noSpace; newLine].append[noSpace; newLine]

	}

//	def dispatch void format(FMessageCollection collection, extension IFormattableDocument document) {
//		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
//		val open = collection.regionFor.keyword("{").prepend[noSpace; newLine].append[noSpace; newLine]
//		val close = collection.regionFor.keyword("}").prepend[noSpace; newLine].append[noSpace; newLine]
//		interior(open, close)[indent]
//		for (FMessage elements : collection.getMessages()) {
//			elements.format;
//			elements.prepend[noSpace; newLine].append[noSpace; newLine]
//		}
//		var v = collection.getVersion
//		{
//			val opena = v.regionFor.keyword("{").prepend[noSpace; newLine].append[noSpace; newLine]
//			val closea = v.regionFor.keyword("}").prepend[noSpace; newLine].append[noSpace; newLine]
//			interior(opena, closea)[indent]
//		}
//		collection.prepend[noSpace; newLine].append[noSpace; newLine]
//
//	}
// TODO: implement for FTypeCollection, , , FTypeDef, FStructType, FEnumerationType, FEnumerator, FMapType, FField
}
